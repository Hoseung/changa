//ParallelGravity.ci

mainmodule ParallelGravity {
	
	extern module Reductions;
	
	readonly CProxy_Main mainChare;
	readonly int verbosity;
	readonly CProxy_TreePiece treeProxy;
	readonly CProxy_TreePiece streamingProxy;
    readonly CProxy_CkCacheManager cacheManagerProxy;
    readonly CProxy_CkCacheManager streamingCache;
	readonly bool _cache;
	readonly int _nocache;
	readonly int _cacheLineDepth;
	readonly unsigned int _yieldPeriod;
	readonly DomainsDec domainDecomposition;
        readonly int peanoKey;
	readonly GenericTrees useTree;
	readonly int _prefetch;
	readonly int _randChunks;
	readonly int _numChunks;
	readonly CkArrayID treePieceID;
	readonly CkGroupID dataManagerID;
        readonly unsigned int numTreePieces;
        readonly unsigned int bucketSize;
        readonly int lbcomm_cutoff_msgs;

        readonly ComlibInstanceHandle cinst1;
        readonly ComlibInstanceHandle cinst2;

        readonly int boundaryEvaluationUE;
        readonly int weightBalanceUE;
        readonly int networkProgressUE;
        readonly int nodeForceUE;
        readonly int partForceUE;

        readonly double theta;
        readonly double thetaMono;

        readonly int nSmooth;
        
	//message piecedata;
	message dummyMsg;
	message ComputeChunkMsg;

        message ORBSplittersMsg{
          double pos[];
          char dim[];
        };

	mainchare [migratable] Main {
		entry Main();
		entry [threaded] void setupICs();
		entry [threaded] void initialForces();
		entry [threaded] void doSimulation();
		entry void restart();
		entry void niceExit();
	};
	
	chare Sorter {
                entry Sorter();
          
                entry void startSorting(const CkGroupID& dataManagerID,
                                        const int nChares, const double toler,
                                        const CkCallback& cb, bool decompose);
                entry void collectEvaluations(CkReductionMsg* m);
                entry void collectORBCounts(CkReductionMsg* m);
                entry void finishPhase(CkReductionMsg* m);
                entry void doORBDecomposition(CkReductionMsg* m);
                entry void readytoSendORB(CkReductionMsg* m);
	};
	
	nodegroup [migratable] DataManager {
		entry DataManager(const CkArrayID& treePieceID);
		
		//entry void acceptCandidateKeys(const SFC::Key keys[n],
		//			       const int n,
        //                                       int isRefine,
		//			       const CkCallback& cb);
		entry void acceptFinalKeys(const SFC::Key keys[n],
					   const int responsible[n - 1],
					   unsigned int bins[n - 1], const int n,
					   const CkCallback& cb);
		entry void collectSplitters(CkReductionMsg* m);
		//entry [local,exclusive] void notifyPresence(int index, Tree::GenericTreeNode *root);
		entry void combineLocalTrees(CkReductionMsg *m);
	};
	array [1D] TreePiece {
		entry TreePiece(unsigned int numPieces);
		entry void restart();

		// DEBUGGING
		entry void quiescence();

		entry void report();
		
		entry void nextBucket(dummyMsg *m);	
		entry void nextBucketSmooth(dummyMsg *msg);
		//entry void registerWithDataManager(const CkGroupID& dataManagerID,
		//		     		  const CkCallback& cb);
		entry void setPeriodic(int nReplicas, double fPeriod,
				       int bEwald, double fEwCut,
				       double fEwhCut, int bPeriodic);
		entry void EwaldInit();
		entry void calculateEwald(dummyMsg *m);
		entry void velScale(double dScale);
		//entry void markPresence(const CkCallback& cb);
		entry void load(const std::string& fn, const CkCallback& cb);
		entry void loadTipsy(const std::string& filename,
				     const CkCallback& cb);
		entry void setupWrite(int iStage, int64_t iPrevOffset,
                                      const std::string& filename, const double dTime,
                                      const double dvFac, const CkCallback& cb);
		entry void reOrder(CkCallback& cb);
		entry void ioAcceptSortedParticles(const GravityParticle particles[n],
					     const int n);
		entry void assignKeys(CkReductionMsg* m);
		entry [nokeep] void evaluateBoundaries(SFC::Key keys[n], const int n, int isRefine, const CkCallback& cb);
		entry void unshuffleParticles(CkReductionMsg* m);
		entry void acceptSortedParticles(const GravityParticle particles[n],
                                                 const int n);
                //ORB
                entry void initORBPieces(const CkCallback& cb);
                entry void initBeforeORBSend(unsigned int myCount, const CkCallback& cb, const CkCallback& cback);
                entry void sendORBParticles();
                entry void acceptORBParticles(const GravityParticle particlesi[n], const int n);
                entry void finalizeBoundaries(ORBSplittersMsg *splittersMsg);
                entry void evaluateParticleCounts(ORBSplittersMsg *splittersMsg);
                
                entry void kick(int iKickRung, double dDelta[MAXRUNG+1],
                                const CkCallback& cb);
		entry void adjust(int iKickRung, int bEpsAccStep,
				int bGravStep, double dEta,
	      			double dDelta, double dAccFac,
				const CkCallback& cb);
                entry void rungStats(const CkCallback& cb);
		entry void drift(double dDelta, const CkCallback& cb);
		entry void calcEnergy(const CkCallback& cb);
		entry void setSoft(const double dSoft);
		entry void setTypeFromFile(int iSetMask, char file[256],
		                           const CkCallback& cb);
		entry void getCOM(const CkCallback& cb);
		entry void getCOMByType(int iType, const CkCallback& cb);
		entry void DumpFrame(InDumpFrame in, const CkCallback& cb) ;
		entry void buildTree(int bucketSize, const CkCallback& cb);
		
		//entry void collectSplitters(CkReductionMsg* m);
		entry void startOctTreeBuild(CkReductionMsg* m);
	
                entry void startORBTreeBuild(CkReductionMsg* m);
                
        entry void startIteration(int activeRung, CkCallback &cb);
        entry void startIterationSmooth(int activeRung, CkCallback &cb);
            
		//entry void acceptBoundaryNodeContribution(Tree::NodeKey key, int numParticles, MultipoleMoments& moments);
		//entry void acceptBoundaryNode(Tree::NodeKey key, int numParticles, MultipoleMoments& moments);
		entry [inline] void requestRemoteMoments(Tree::NodeKey key, int sender);
		entry void receiveRemoteMoments(Tree::NodeKey key, Tree::NodeType type, int firstParticle, int numParticles, MultipoleMoments& moments, OrientedBox<double>& box);
		
		//entry void calculateGravityDirect(const CkCallback& cb);
		//entry void fillRequestDirect(GravityRequest req);
		//entry void receiveGravityDirect(const GravityRequest& req);
		
		//entry void calculateGravityTree(double t, const CkCallback& cb);
		//entry void fillRequestTree(GravityRequest req);	
		//entry void receiveGravityTree(const GravityRequest& req);
		
		entry void calculateGravityLocal();
		entry void calculateGravityRemote(ComputeChunkMsg *msg);

		entry void calculateSmoothLocal();

		//entry void fillRequestBucketTree(BucketGravityRequest req);	
		//entry void receiveGravityBucketTree(const BucketGravityRequest& req);

		//entry void fillRequestNode(int retIndex, Tree::NodeKey lookupKey,
		//			   BucketGravityRequest &req);
		entry [expedited] void fillRequestNode(CkCacheRequestMsg *msg);
		entry [local] void receiveNodeCallback(GenericTreeNode *node, int chunk, int reqID, int awi);
		//entry void receiveNode(GenericTreeNode node[1],
		//	       unsigned int reqID);
		//entry [inline] void receiveNode_inline(GenericTreeNode node[1],
		//				       unsigned int reqID);
		//entry void fillRequestParticle(int retIndex, int pi,
		//				BucketGravityRequest &req);
		//entry void receiveParticle(GravityParticle part,
		//			   BucketGravityRequest &req);
		entry [expedited] void fillRequestParticles(CkCacheRequestMsg *msg);
		entry void flushSmoothParticles(CkCacheFillMsg *msg);
        entry [local] void receiveParticlesCallback(ExternalGravityParticle *egp, int num, int chunk, int reqID, Tree::NodeKey &remoteBucket, int awi);
		//entry void fillRequestParticles(SFC::Key key,int retIndex, int begin,int end,
		//				unsigned int reqID);
		//entry void receiveParticles(ExternalGravityParticle part[num],int num,int chunk,
		//			    unsigned int reqID);
		//entry [inline] void receiveParticles_inline(GravityParticle part[num],int num,
		//					    unsigned int reqID);
		    
                // jetley
		entry void startlb(CkCallback &cb, int activeRung);
		entry void ResumeFromSync();
                //jetley
                entry void receiveProxy(CkGroupID);
                entry void doAtSync();

		entry void outputAccelerations(OrientedBox<double> accelerationBox, const std::string& suffix, const CkCallback& cb);
		entry void outputAccASCII(const std::string& suffix, const CkCallback& cb);
		entry void outputIOrderASCII(const std::string& suffix, const CkCallback& cb);
		entry void outputDensityASCII(const std::string& suffix, const CkCallback& cb);
		entry void outputStatistics(Interval<unsigned int> macInterval, Interval<unsigned int> cellInterval, Interval<unsigned int> particleInterval, Interval<unsigned int> callsInterval, double totalmass, const CkCallback& cb);
		//entry void outputRelativeErrors(Interval<double> errorInterval, const CkCallback& cb);
		//entry void getPieceValues(piecedata *totaldata);
		entry void collectStatistics(CkCallback &cb);
	};

	initproc void registerStatistics();
};
